<!DOCTYPE html>
<html>
<!-- Created by GNU Texinfo 7.0.1, https://www.gnu.org/software/texinfo/ -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<!-- This manual documents Guile version 3.0.9.

Copyright (C) 1996-1997, 2000-2005, 2009-2023 Free Software Foundation,
Inc. 

Copyright (C) 2021 Maxime Devos

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with no
Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.  A
copy of the license is included in the section entitled "GNU Free
Documentation License." -->
<title>rnrs arithmetic fixnums (Guile Reference Manual)</title>

<meta name="description" content="rnrs arithmetic fixnums (Guile Reference Manual)">
<meta name="keywords" content="rnrs arithmetic fixnums (Guile Reference Manual)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<meta name="viewport" content="width=device-width,initial-scale=1">

<link href="index.html" rel="start" title="Top">
<link href="Concept-Index.html" rel="index" title="Concept Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="R6RS-Standard-Libraries.html" rel="up" title="R6RS Standard Libraries">
<link href="rnrs-arithmetic-flonums.html" rel="next" title="rnrs arithmetic flonums">
<link href="rnrs-programs.html" rel="prev" title="rnrs programs">
<style type="text/css">
<!--
a.copiable-link {visibility: hidden; text-decoration: none; line-height: 0em}
div.example {margin-left: 3.2em}
span:hover a.copiable-link {visibility: visible}
strong.def-name {font-family: monospace; font-weight: bold; font-size: larger}
-->
</style>
<link rel="stylesheet" type="text/css" href="https://www.gnu.org/software/gnulib/manual.css">


</head>

<body lang="en">
<div class="subsubsection-level-extent" id="rnrs-arithmetic-fixnums">
<div class="nav-panel">
<p>
Next: <a href="rnrs-arithmetic-flonums.html" accesskey="n" rel="next">rnrs arithmetic flonums</a>, Previous: <a href="rnrs-programs.html" accesskey="p" rel="prev">rnrs programs</a>, Up: <a href="R6RS-Standard-Libraries.html" accesskey="u" rel="up">R6RS Standard Libraries</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Concept-Index.html" title="Index" rel="index">Index</a>]</p>
</div>
<hr>
<h4 class="subsubsection" id="rnrs-arithmetic-fixnums-1">7.6.2.21 rnrs arithmetic fixnums</h4>

<p>The <code class="code">(rnrs arithmetic fixnums (6))</code> library provides procedures for
performing arithmetic operations on an implementation-dependent range of
exact integer values, which R6RS refers to as <em class="dfn">fixnums</em>.  In Guile,
the size of a fixnum is determined by the size of the <code class="code">SCM</code> type; a
single SCM struct is guaranteed to be able to hold an entire fixnum, 
making fixnum computations particularly 
efficient&mdash;(see <a class="pxref" href="The-SCM-Type.html">The SCM Type</a>).  On 32-bit systems, the most 
negative and most positive fixnum values are, respectively, -536870912 
and 536870911.
</p>
<p>Unless otherwise specified, all of the procedures below take fixnums as
arguments, and will raise an <code class="code">&amp;assertion</code> condition if passed a 
non-fixnum argument or an <code class="code">&amp;implementation-restriction</code> condition 
if their result is not itself a fixnum.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-fixnum_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">fixnum?</strong> <var class="def-var-arguments">obj</var><a class="copiable-link" href='#index-fixnum_003f'> &para;</a></span></dt>
<dd><p>Returns <code class="code">#t</code> if <var class="var">obj</var> is a fixnum, <code class="code">#f</code> otherwise.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-fixnum_002dwidth"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">fixnum-width</strong><a class="copiable-link" href='#index-fixnum_002dwidth'> &para;</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-least_002dfixnum"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">least-fixnum</strong><a class="copiable-link" href='#index-least_002dfixnum'> &para;</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-greatest_002dfixnum"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">greatest-fixnum</strong><a class="copiable-link" href='#index-greatest_002dfixnum'> &para;</a></span></dt>
<dd><p>These procedures return, respectively, the maximum number of bits 
necessary to represent a fixnum value in Guile, the minimum fixnum
value, and the maximum fixnum value.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-fx_003d_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">fx=?</strong> <var class="def-var-arguments">fx1 fx2 fx3 ...</var><a class="copiable-link" href='#index-fx_003d_003f'> &para;</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-fx_003e_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">fx&gt;?</strong> <var class="def-var-arguments">fx1 fx2 fx3 ...</var><a class="copiable-link" href='#index-fx_003e_003f'> &para;</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-fx_003c_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">fx&lt;?</strong> <var class="def-var-arguments">fx1 fx2 fx3 ...</var><a class="copiable-link" href='#index-fx_003c_003f'> &para;</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-fx_003e_003d_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">fx&gt;=?</strong> <var class="def-var-arguments">fx1 fx2 fx3 ...</var><a class="copiable-link" href='#index-fx_003e_003d_003f'> &para;</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-fx_003c_003d_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">fx&lt;=?</strong> <var class="def-var-arguments">fx1 fx2 fx3 ...</var><a class="copiable-link" href='#index-fx_003c_003d_003f'> &para;</a></span></dt>
<dd><p>These procedures return <code class="code">#t</code> if their fixnum arguments are
(respectively): equal, monotonically increasing, monotonically
decreasing, monotonically nondecreasing, or monotonically nonincreasing;
<code class="code">#f</code> otherwise.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-fxzero_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">fxzero?</strong> <var class="def-var-arguments">fx</var><a class="copiable-link" href='#index-fxzero_003f'> &para;</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-fxpositive_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">fxpositive?</strong> <var class="def-var-arguments">fx</var><a class="copiable-link" href='#index-fxpositive_003f'> &para;</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-fxnegative_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">fxnegative?</strong> <var class="def-var-arguments">fx</var><a class="copiable-link" href='#index-fxnegative_003f'> &para;</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-fxodd_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">fxodd?</strong> <var class="def-var-arguments">fx</var><a class="copiable-link" href='#index-fxodd_003f'> &para;</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-fxeven_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">fxeven?</strong> <var class="def-var-arguments">fx</var><a class="copiable-link" href='#index-fxeven_003f'> &para;</a></span></dt>
<dd><p>These numerical predicates return <code class="code">#t</code> if <var class="var">fx</var> is,
respectively, zero, greater than zero, less than zero, odd, or even;
<code class="code">#f</code> otherwise. 
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-fxmax"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">fxmax</strong> <var class="def-var-arguments">fx1 fx2 ...</var><a class="copiable-link" href='#index-fxmax'> &para;</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-fxmin"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">fxmin</strong> <var class="def-var-arguments">fx1 fx2 ...</var><a class="copiable-link" href='#index-fxmin'> &para;</a></span></dt>
<dd><p>These procedures return the maximum or minimum of their arguments.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-fx_002b"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">fx+</strong> <var class="def-var-arguments">fx1 fx2</var><a class="copiable-link" href='#index-fx_002b'> &para;</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-fx_002a"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">fx*</strong> <var class="def-var-arguments">fx1 fx2</var><a class="copiable-link" href='#index-fx_002a'> &para;</a></span></dt>
<dd><p>These procedures return the sum or product of their arguments.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-fx_002d"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">fx-</strong> <var class="def-var-arguments">fx1 fx2</var><a class="copiable-link" href='#index-fx_002d'> &para;</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-fx_002d-1"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">fx-</strong> <var class="def-var-arguments">fx</var><a class="copiable-link" href='#index-fx_002d-1'> &para;</a></span></dt>
<dd><p>Returns the difference of <var class="var">fx1</var> and <var class="var">fx2</var>, or the negation of
<var class="var">fx</var>, if called with a single argument.
</p>
<p>An <code class="code">&amp;assertion</code> condition is raised if the result is not itself a
fixnum.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-fxdiv_002dand_002dmod"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">fxdiv-and-mod</strong> <var class="def-var-arguments">fx1 fx2</var><a class="copiable-link" href='#index-fxdiv_002dand_002dmod'> &para;</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-fxdiv"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">fxdiv</strong> <var class="def-var-arguments">fx1 fx2</var><a class="copiable-link" href='#index-fxdiv'> &para;</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-fxmod"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">fxmod</strong> <var class="def-var-arguments">fx1 fx2</var><a class="copiable-link" href='#index-fxmod'> &para;</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-fxdiv0_002dand_002dmod0"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">fxdiv0-and-mod0</strong> <var class="def-var-arguments">fx1 fx2</var><a class="copiable-link" href='#index-fxdiv0_002dand_002dmod0'> &para;</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-fxdiv0"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">fxdiv0</strong> <var class="def-var-arguments">fx1 fx2</var><a class="copiable-link" href='#index-fxdiv0'> &para;</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-fxmod0"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">fxmod0</strong> <var class="def-var-arguments">fx1 fx2</var><a class="copiable-link" href='#index-fxmod0'> &para;</a></span></dt>
<dd><p>These procedures implement number-theoretic division on fixnums;
See <a data-manual="rnrs base" href="../rnrs%20base_html/index.html">(rnrs base)</a>, for a description of their semantics.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-fx_002b_002fcarry"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">fx+/carry</strong> <var class="def-var-arguments">fx1 fx2 fx3</var><a class="copiable-link" href='#index-fx_002b_002fcarry'> &para;</a></span></dt>
<dd><p>Returns the two fixnum results of the following computation:
</p><div class="example lisp">
<pre class="lisp-preformatted">(let* ((s (+ fx1 fx2 fx3))
       (s0 (mod0 s (expt 2 (fixnum-width))))
       (s1 (div0 s (expt 2 (fixnum-width)))))
  (values s0 s1))
</pre></div>
</dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-fx_002d_002fcarry"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">fx-/carry</strong> <var class="def-var-arguments">fx1 fx2 fx3</var><a class="copiable-link" href='#index-fx_002d_002fcarry'> &para;</a></span></dt>
<dd><p>Returns the two fixnum results of the following computation:
</p><div class="example lisp">
<pre class="lisp-preformatted">(let* ((d (- fx1 fx2 fx3))
       (d0 (mod0 d (expt 2 (fixnum-width))))
       (d1 (div0 d (expt 2 (fixnum-width)))))
  (values d0 d1))
</pre></div>
</dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-fx_002a_002fcarry"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">fx*/carry</strong> <var class="def-var-arguments">fx1 fx2 fx3</var><a class="copiable-link" href='#index-fx_002a_002fcarry'> &para;</a></span></dt>
<dd><div class="example lisp">
<pre class="lisp-preformatted">Returns the two fixnum results of the following computation:
(let* ((s (+ (* fx1 fx2) fx3))
       (s0 (mod0 s (expt 2 (fixnum-width))))
       (s1 (div0 s (expt 2 (fixnum-width)))))
  (values s0 s1))
</pre></div>
</dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-fxnot"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">fxnot</strong> <var class="def-var-arguments">fx</var><a class="copiable-link" href='#index-fxnot'> &para;</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-fxand"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">fxand</strong> <var class="def-var-arguments">fx1 ...</var><a class="copiable-link" href='#index-fxand'> &para;</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-fxior"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">fxior</strong> <var class="def-var-arguments">fx1 ...</var><a class="copiable-link" href='#index-fxior'> &para;</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-fxxor"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">fxxor</strong> <var class="def-var-arguments">fx1 ...</var><a class="copiable-link" href='#index-fxxor'> &para;</a></span></dt>
<dd><p>These procedures are identical to the <code class="code">lognot</code>, <code class="code">logand</code>,
<code class="code">logior</code>, and <code class="code">logxor</code> procedures provided by Guile&rsquo;s core
library.  See <a class="xref" href="Bitwise-Operations.html">Bitwise Operations</a>, for documentation.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-fxif"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">fxif</strong> <var class="def-var-arguments">fx1 fx2 fx3</var><a class="copiable-link" href='#index-fxif'> &para;</a></span></dt>
<dd><p>Returns the bitwise &ldquo;if&rdquo; of its fixnum arguments.  The bit at position
<code class="code">i</code> in the return value will be the <code class="code">i</code>th bit from <var class="var">fx2</var>
if the <code class="code">i</code>th bit of <var class="var">fx1</var> is 1, the <code class="code">i</code>th bit from 
<var class="var">fx3</var>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-fxbit_002dcount"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">fxbit-count</strong> <var class="def-var-arguments">fx</var><a class="copiable-link" href='#index-fxbit_002dcount'> &para;</a></span></dt>
<dd><p>Returns the number of 1 bits in the two&rsquo;s complement representation of
<var class="var">fx</var>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-fxlength"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">fxlength</strong> <var class="def-var-arguments">fx</var><a class="copiable-link" href='#index-fxlength'> &para;</a></span></dt>
<dd><p>Returns the number of bits necessary to represent <var class="var">fx</var>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-fxfirst_002dbit_002dset"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">fxfirst-bit-set</strong> <var class="def-var-arguments">fx</var><a class="copiable-link" href='#index-fxfirst_002dbit_002dset'> &para;</a></span></dt>
<dd><p>Returns the index of the least significant 1 bit in the two&rsquo;s complement
representation of <var class="var">fx</var>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-fxbit_002dset_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">fxbit-set?</strong> <var class="def-var-arguments">fx1 fx2</var><a class="copiable-link" href='#index-fxbit_002dset_003f'> &para;</a></span></dt>
<dd><p>Returns <code class="code">#t</code> if the <var class="var">fx2</var>th bit in the two&rsquo;s complement
representation of <var class="var">fx1</var> is 1, <code class="code">#f</code> otherwise.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-fxcopy_002dbit"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">fxcopy-bit</strong> <var class="def-var-arguments">fx1 fx2 fx3</var><a class="copiable-link" href='#index-fxcopy_002dbit'> &para;</a></span></dt>
<dd><p>Returns the result of setting the <var class="var">fx2</var>th bit of <var class="var">fx1</var> to the
<var class="var">fx2</var>th bit of <var class="var">fx3</var>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-fxbit_002dfield"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">fxbit-field</strong> <var class="def-var-arguments">fx1 fx2 fx3</var><a class="copiable-link" href='#index-fxbit_002dfield'> &para;</a></span></dt>
<dd><p>Returns the integer representation of the contiguous sequence of bits in
<var class="var">fx1</var> that starts at position <var class="var">fx2</var> (inclusive) and ends at
position <var class="var">fx3</var> (exclusive).
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-fxcopy_002dbit_002dfield"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">fxcopy-bit-field</strong> <var class="def-var-arguments">fx1 fx2 fx3 fx4</var><a class="copiable-link" href='#index-fxcopy_002dbit_002dfield'> &para;</a></span></dt>
<dd><p>Returns the result of replacing the bit field in <var class="var">fx1</var> with start
and end positions <var class="var">fx2</var> and <var class="var">fx3</var> with the corresponding bit
field from <var class="var">fx4</var>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-fxarithmetic_002dshift"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">fxarithmetic-shift</strong> <var class="def-var-arguments">fx1 fx2</var><a class="copiable-link" href='#index-fxarithmetic_002dshift'> &para;</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-fxarithmetic_002dshift_002dleft"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">fxarithmetic-shift-left</strong> <var class="def-var-arguments">fx1 fx2</var><a class="copiable-link" href='#index-fxarithmetic_002dshift_002dleft'> &para;</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-fxarithmetic_002dshift_002dright"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">fxarithmetic-shift-right</strong> <var class="def-var-arguments">fx1 fx2</var><a class="copiable-link" href='#index-fxarithmetic_002dshift_002dright'> &para;</a></span></dt>
<dd><p>Returns the result of shifting the bits of <var class="var">fx1</var> right or left by
the <var class="var">fx2</var> positions.  <code class="code">fxarithmetic-shift</code> is identical
to <code class="code">fxarithmetic-shift-left</code>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-fxrotate_002dbit_002dfield"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">fxrotate-bit-field</strong> <var class="def-var-arguments">fx1 fx2 fx3 fx4</var><a class="copiable-link" href='#index-fxrotate_002dbit_002dfield'> &para;</a></span></dt>
<dd><p>Returns the result of cyclically permuting the bit field in <var class="var">fx1</var>
with start and end positions <var class="var">fx2</var> and <var class="var">fx3</var> by <var class="var">fx4</var> bits
in the direction of more significant bits.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-fxreverse_002dbit_002dfield"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">fxreverse-bit-field</strong> <var class="def-var-arguments">fx1 fx2 fx3</var><a class="copiable-link" href='#index-fxreverse_002dbit_002dfield'> &para;</a></span></dt>
<dd><p>Returns the result of reversing the order of the bits of <var class="var">fx1</var> 
between position <var class="var">fx2</var> (inclusive) and position <var class="var">fx3</var> 
(exclusive).
</p></dd></dl>

</div>
<hr>
<div class="nav-panel">
<p>
Next: <a href="rnrs-arithmetic-flonums.html">rnrs arithmetic flonums</a>, Previous: <a href="rnrs-programs.html">rnrs programs</a>, Up: <a href="R6RS-Standard-Libraries.html">R6RS Standard Libraries</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Concept-Index.html" title="Index" rel="index">Index</a>]</p>
</div>



</body>
</html>
