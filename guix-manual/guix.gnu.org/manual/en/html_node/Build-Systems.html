<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<!--   Copyright (C) 2012-2022 Ludovic Courtès

Copyright (C) 2013, 2014, 2016 Andreas Enge

Copyright (C) 2013 Nikita Karetnikov

Copyright (C) 2014, 2015, 2016 Alex Kost

Copyright (C) 2015, 2016 Mathieu Lirzin

Copyright (C) 2014 Pierre-Antoine Rault

Copyright (C) 2015 Taylan Ulrich Bayırlı/Kammer

Copyright (C) 2015, 2016, 2017, 2019, 2020, 2021 Leo Famulari

Copyright (C) 2015, 2016, 2017, 2018, 2019, 2020, 2021, 2022 Ricardo Wurmus

Copyright (C) 2016 Ben Woodcroft

Copyright (C) 2016, 2017, 2018, 2021 Chris Marusich

Copyright (C) 2016, 2017, 2018, 2019, 2020, 2021, 2022 Efraim Flashner

Copyright (C) 2016 John Darrington

Copyright (C) 2016, 2017 Nikita Gillmann

Copyright (C) 2016, 2017, 2018, 2019, 2020 Jan Nieuwenhuizen

Copyright (C) 2016, 2017, 2018, 2019, 2020, 2021 Julien Lepiller

Copyright (C) 2016 Alex ter Weele

Copyright (C) 2016, 2017, 2018, 2019, 2020, 2021 Christopher Baines

Copyright (C) 2017, 2018, 2019 Clément Lassieur

Copyright (C) 2017, 2018, 2020, 2021, 2022 Mathieu Othacehe

Copyright (C) 2017 Federico Beffa

Copyright (C) 2017, 2018 Carlo Zancanaro

Copyright (C) 2017 Thomas Danckaert

Copyright (C) 2017 humanitiesNerd

Copyright (C) 2017, 2021 Christine Lemmer-Webber

Copyright (C) 2017, 2018, 2019, 2020, 2021, 2022 Marius Bakke

Copyright (C) 2017, 2019, 2020, 2022 Hartmut Goebel

Copyright (C) 2017, 2019, 2020, 2021, 2022 Maxim Cournoyer

Copyright (C) 2017–2022 Tobias Geerinckx-Rice

Copyright (C) 2017 George Clemmer

Copyright (C) 2017 Andy Wingo

Copyright (C) 2017, 2018, 2019, 2020 Arun Isaac

Copyright (C) 2017 nee

Copyright (C) 2018 Rutger Helling

Copyright (C) 2018, 2021 Oleg Pykhalov

Copyright (C) 2018 Mike Gerwitz

Copyright (C) 2018 Pierre-Antoine Rouby

Copyright (C) 2018, 2019 Gábor Boskovits

Copyright (C) 2018, 2019, 2020, 2022 Florian Pelz

Copyright (C) 2018 Laura Lazzati

Copyright (C) 2018 Alex Vong

Copyright (C) 2019 Josh Holland

Copyright (C) 2019, 2020 Diego Nicola Barbato

Copyright (C) 2019 Ivan Petkov

Copyright (C) 2019 Jakob L. Kreuze

Copyright (C) 2019 Kyle Andrews

Copyright (C) 2019 Alex Griffin

Copyright (C) 2019, 2020, 2021, 2022 Guillaume Le Vaillant

Copyright (C) 2020 Liliana Marie Prikler

Copyright (C) 2019, 2020, 2021, 2022 Simon Tournier

Copyright (C) 2020 Wiktor Żelazny

Copyright (C) 2020 Damien Cassou

Copyright (C) 2020 Jakub Kądziołka

Copyright (C) 2020 Jack Hill

Copyright (C) 2020 Naga Malleswari

Copyright (C) 2020, 2021 Brice Waegeneire

Copyright (C) 2020 R Veera Kumar

Copyright (C) 2020, 2021 Pierre Langlois

Copyright (C) 2020 pinoaffe

Copyright (C) 2020 André Batista

Copyright (C) 2020, 2021 Alexandru-Sergiu Marton

Copyright (C) 2020 raingloom

Copyright (C) 2020 Daniel Brooks

Copyright (C) 2020 John Soo

Copyright (C) 2020 Jonathan Brielmaier

Copyright (C) 2020 Edgar Vincent

Copyright (C) 2021, 2022 Maxime Devos

Copyright (C) 2021 B. Wilson

Copyright (C) 2021 Xinglu Chen

Copyright (C) 2021 Raghav Gururajan

Copyright (C) 2021 Domagoj Stolfa

Copyright (C) 2021 Hui Lu

Copyright (C) 2021 pukkamustard

Copyright (C) 2021 Alice Brenon

Copyright (C) 2021, 2022 Josselin Poiret

Copyright (C) 2021 muradm

Copyright (C) 2021, 2022 Andrew Tropin

Copyright (C) 2021 Sarah Morgensen

Copyright (C) 2022 Remco van 't Veer

Copyright (C) 2022 Aleksandr Vityazev

Copyright (C) 2022 Philip McGrath

Copyright (C) 2022 Karl Hallsby

Copyright (C) 2022 Justin Veilleux

Copyright (C) 2022 Reily Siegel

Copyright (C) 2022 Simon Streit

Copyright (C) 2022 (

Copyright (C) 2022 John Kehayias


Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with no
Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.  A
copy of the license is included in the section entitled "GNU Free
Documentation License".   -->
<!--   Created by GNU Texinfo 6.7, http://www.gnu.org/software/texinfo/   -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Build Systems (GNU Guix Reference Manual)</title>

<meta name="description" content="Build Systems (GNU Guix Reference Manual)" />
<meta name="keywords" content="Build Systems (GNU Guix Reference Manual)" />
<meta name="resource-type" content="document" />
<meta name="distribution" content="global" />
<meta name="Generator" content="makeinfo" />
<link href="index.html" rel="start" title="Top" />
<link href="Concept-Index.html" rel="index" title="Concept Index" />
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents" />
<link href="Programming-Interface.html" rel="up" title="Programming Interface" />
<link href="Build-Phases.html" rel="next" title="Build Phases" />
<link href="Writing-Manifests.html" rel="prev" title="Writing Manifests" />
<style type="text/css">
&amp;lt;!--
a.summary-letter {text-decoration: none}
blockquote.indentedblock {margin-right: 0em}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
kbd {font-style: oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
span.nolinebreak {white-space: nowrap}
span.roman {font-family: initial; font-weight: normal}
span.sansserif {font-family: sans-serif; font-weight: normal}
ul.no-bullet {list-style: none}
--&amp;gt;
</style>
<link rel="stylesheet" type="text/css" href="https://www.gnu.org/software/gnulib/manual.css" />

<meta name="viewport" content="width=device-width, initial-scale=1" />
<link rel="stylesheet" type="text/css" href="../../../static/base/css/manual.css" /><link rel="stylesheet" type="text/css" href="../../../static/base/css/code.css" /></head>

<body lang="en"><header class="navbar"><h1><a class="branding" href="https://guix.gnu.org/manual/en/"></a></h1><nav class="navbar-menu"><input class="navbar-menu-hidden-input" type="radio" name="dropdown" id="all-dropdowns-hidden" /><ul><li class="navbar-menu-item dropdown dropdown-btn"><input class="navbar-menu-hidden-input" type="radio" name="dropdown" id="visible-dropdown" /><label for="visible-dropdown"><img alt="Language" src="../../../static/base/img/language-picker.svg" /></label><label for="all-dropdowns-hidden"><img alt="Language" src="../../../static/base/img/language-picker.svg" /></label><div class="navbar-submenu" id="navbar-submenu"><div class="navbar-submenu-triangle"> </div><ul><li><a class="navbar-menu-item" href="https://guix.gnu.org/manual/de/html_node">Deutsch</a></li><li><a class="navbar-menu-item" href="https://guix.gnu.org/manual/en/html_node">English</a></li><li><a class="navbar-menu-item" href="https://guix.gnu.org/manual/es/html_node">Español</a></li><li><a class="navbar-menu-item" href="https://guix.gnu.org/manual/fr/html_node">français</a></li><li><a class="navbar-menu-item" href="https://guix.gnu.org/manual/pt-br/html_node">Português</a></li><li><a class="navbar-menu-item" href="https://guix.gnu.org/manual/ru/html_node">русский</a></li><li><a class="navbar-menu-item" href="https://guix.gnu.org/manual/zh-cn/html_node">中文</a></li><li><a class="navbar-menu-item" href="https://translate.fedoraproject.org/projects/guix/documentation-manual/">⊕</a></li></ul></div></li></ul></nav><a class="navbar-menu-btn" href="https://guix.gnu.org/manual/"></a></header>
<span id="Build-Systems"></span><div class="header">
<p>
Next: <a href="Build-Phases.html" accesskey="n" rel="next">Build Phases</a>, Previous: <a href="Writing-Manifests.html" accesskey="p" rel="prev">Writing Manifests</a>, Up: <a href="Programming-Interface.html" accesskey="u" rel="up">Programming Interface</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Concept-Index.html" title="Index" rel="index">Index</a>]</p>
</div>
<hr />
<span id="Build-Systems-1"></span><h3 class="section">9.5 Build Systems</h3>

<span id="index-build-system"></span>
<p>Each package definition specifies a <em>build system</em> and arguments for
that build system (see <a href="Defining-Packages.html">Defining Packages</a>).  This <code>build-system</code>
field represents the build procedure of the package, as well as implicit
dependencies of that build procedure.
</p>
<p>Build systems are <code>&lt;build-system&gt;</code> objects.  The interface to
create and manipulate them is provided by the <code>(guix build-system)</code>
module, and actual build systems are exported by specific modules.
</p>
<span id="index-bag-_0028low_002dlevel-package-representation_0029"></span>
<p>Under the hood, build systems first compile package objects to
<em>bags</em>.  A <em>bag</em> is like a package, but with less
ornamentation&mdash;in other words, a bag is a lower-level representation of
a package, which includes all the inputs of that package, including some
that were implicitly added by the build system.  This intermediate
representation is then compiled to a derivation (see <a href="Derivations.html">Derivations</a>).
The <code>package-with-c-toolchain</code> is an example of a way to change the
implicit inputs that a package&rsquo;s build system pulls in (see <a href="package-Reference.html"><code>package-with-c-toolchain</code></a>).
</p>
<p>Build systems accept an optional list of <em>arguments</em>.  In package
definitions, these are passed <i>via</i> the <code>arguments</code> field
(see <a href="Defining-Packages.html">Defining Packages</a>).  They are typically keyword arguments
(see <a href="https://www.gnu.org/software/guile/manual/html_node/Optional-Arguments.html#Optional-Arguments">keyword arguments in Guile</a> in <cite>GNU
Guile Reference Manual</cite>).  The value of these arguments is usually
evaluated in the <em>build stratum</em>&mdash;i.e., by a Guile process launched
by the daemon (see <a href="Derivations.html">Derivations</a>).
</p>
<p>The main build system is <code>gnu-build-system</code>, which implements the
standard build procedure for GNU and many other packages.  It
is provided by the <code>(guix build-system gnu)</code> module.
</p>
<dl>
<dt id="index-gnu_002dbuild_002dsystem" class="symbol-definition"><span class="symbol-definition-category">Scheme Variable: </span><span class="symbol-definition-prototype">gnu-build-system </span></dt>
<dd><p><code>gnu-build-system</code> represents the GNU Build System, and variants
thereof (see <a href="https://www.gnu.org/prep/standards/html_node/Configuration.html#Configuration">configuration and makefile conventions</a> in <cite>GNU Coding Standards</cite>).
</p>
<span id="index-build-phases"></span>
<p>In a nutshell, packages using it are configured, built, and installed with
the usual <code>./configure &amp;&amp; make &amp;&amp; make check &amp;&amp; make install</code>
command sequence.  In practice, a few additional steps are often needed.
All these steps are split up in separate <em>phases</em>.
See <a href="Build-Phases.html">Build Phases</a>, for more info on build phases and ways to customize
them.
</p>
<p>In addition, this build system ensures that the &ldquo;standard&rdquo; environment
for GNU packages is available.  This includes tools such as GCC, libc,
Coreutils, Bash, Make, Diffutils, grep, and sed (see the <code>(guix
build-system gnu)</code> module for a complete list).  We call these the
<em>implicit inputs</em> of a package, because package definitions do not
have to mention them.
</p>
<p>This build system supports a number of keyword arguments, which can be
passed <i>via</i> the <code>arguments</code> field of a package.  Here are some
of the main parameters:
</p>
<dl compact="compact">
<dt><code>#:phases</code></dt>
<dd><p>This argument specifies build-side code that evaluates to an alist of
build phases.  See <a href="Build-Phases.html">Build Phases</a>, for more information.
</p>
</dd>
<dt><code>#:configure-flags</code></dt>
<dd><p>This is a list of flags (strings) passed to the <code>configure</code>
script.  See <a href="Defining-Packages.html">Defining Packages</a>, for an example.
</p>
</dd>
<dt><code>#:make-flags</code></dt>
<dd><p>This list of strings contains flags passed as arguments to
<code>make</code> invocations in the <code>build</code>, <code>check</code>, and
<code>install</code> phases.
</p>
</dd>
<dt><code>#:out-of-source?</code></dt>
<dd><p>This Boolean, <code>#f</code> by default, indicates whether to run builds in a
build directory separate from the source tree.
</p>
<p>When it is true, the <code>configure</code> phase creates a separate build
directory, changes to that directory, and runs the <code>configure</code>
script from there.  This is useful for packages that require it, such as
<code>glibc</code>.
</p>
</dd>
<dt><code>#:tests?</code></dt>
<dd><p>This Boolean, <code>#t</code> by default, indicates whether the <code>check</code>
phase should run the package&rsquo;s test suite.
</p>
</dd>
<dt><code>#:test-target</code></dt>
<dd><p>This string, <code>"check"</code> by default, gives the name of the makefile
target used by the <code>check</code> phase.
</p>
</dd>
<dt><code>#:parallel-build?</code></dt>
<dt><code>#:parallel-tests?</code></dt>
<dd><p>These Boolean values specify whether to build, respectively run the test
suite, in parallel, with the <code>-j</code> flag of <code>make</code>.  When
they are true, <code>make</code> is passed <code>-j<var>n</var></code>, where <var>n</var> is
the number specified as the <samp>--cores</samp> option of
<code>guix-daemon</code> or that of the <code>guix</code> client command
(see <a href="Common-Build-Options.html"><samp>--cores</samp></a>).
</p>
<span id="index-RUNPATH_002c-validation"></span>
</dd>
<dt><code>#:validate-runpath?</code></dt>
<dd><p>This Boolean, <code>#t</code> by default, determines whether to &ldquo;validate&rdquo;
the <code>RUNPATH</code> of ELF binaries (<code>.so</code> shared libraries as well
as executables) previously installed by the <code>install</code> phase.
See <a href="Build-Phases.html#phase_002dvalidate_002drunpath">the <code>validate-runpath</code> phase</a>, for
details.
</p>
</dd>
<dt><code>#:substitutable?</code></dt>
<dd><p>This Boolean, <code>#t</code> by default, tells whether the package outputs
should be substitutable&mdash;i.e., whether users should be able to obtain
substitutes for them instead of building locally (see <a href="Substitutes.html">Substitutes</a>).
</p>
</dd>
<dt><code>#:allowed-references</code></dt>
<dt><code>#:disallowed-references</code></dt>
<dd><p>When true, these arguments must be a list of dependencies that must not
appear among the references of the build results.  If, upon build
completion, some of these references are retained, the build process
fails.
</p>
<p>This is useful to ensure that a package does not erroneously keep a
reference to some of it build-time inputs, in cases where doing so
would, for example, unnecessarily increase its size (see <a href="Invoking-guix-size.html">Invoking guix size</a>).
</p></dd>
</dl>

<p>Most other build systems support these keyword arguments.
</p></dd></dl>

<p>Other <code>&lt;build-system&gt;</code> objects are defined to support other
conventions and tools used by free software packages.  They inherit most
of <code>gnu-build-system</code>, and differ mainly in the set of inputs
implicitly added to the build process, and in the list of phases
executed.  Some of these build systems are listed below.
</p>
<dl>
<dt id="index-ant_002dbuild_002dsystem" class="symbol-definition"><span class="symbol-definition-category">Scheme Variable: </span><span class="symbol-definition-prototype">ant-build-system </span></dt>
<dd><p>This variable is exported by <code>(guix build-system ant)</code>.  It
implements the build procedure for Java packages that can be built with
<a href="https://ant.apache.org/">Ant build tool</a>.
</p>
<p>It adds both <code>ant</code> and the <em>Java Development Kit</em> (JDK) as
provided by the <code>icedtea</code> package to the set of inputs.  Different
packages can be specified with the <code>#:ant</code> and <code>#:jdk</code>
parameters, respectively.
</p>
<p>When the original package does not provide a suitable Ant build file,
the parameter <code>#:jar-name</code> can be used to generate a minimal Ant
build file <samp>build.xml</samp> with tasks to build the specified jar
archive.  In this case the parameter <code>#:source-dir</code> can be used to
specify the source sub-directory, defaulting to &ldquo;src&rdquo;.
</p>
<p>The <code>#:main-class</code> parameter can be used with the minimal ant
buildfile to specify the main class of the resulting jar.  This makes the
jar file executable.  The <code>#:test-include</code> parameter can be used to
specify the list of junit tests to run.  It defaults to
<code>(list "**/*Test.java")</code>.  The <code>#:test-exclude</code> can be used to
disable some tests.  It defaults to <code>(list "**/Abstract*.java")</code>,
because abstract classes cannot be run as tests.
</p>
<p>The parameter <code>#:build-target</code> can be used to specify the Ant task
that should be run during the <code>build</code> phase.  By default the
&ldquo;jar&rdquo; task will be run.
</p>
</dd></dl>

<dl>
<dt id="index-android_002dndk_002dbuild_002dsystem" class="symbol-definition"><span class="symbol-definition-category">Scheme Variable: </span><span class="symbol-definition-prototype">android-ndk-build-system </span></dt>
<dd><span id="index-Android-distribution"></span>
<span id="index-Android-NDK-build-system"></span>
<p>This variable is exported by <code>(guix build-system android-ndk)</code>.  It
implements a build procedure for Android NDK (native development kit)
packages using a Guix-specific build process.
</p>
<p>The build system assumes that packages install their public interface
(header) files to the subdirectory <samp>include</samp> of the <code>out</code> output and
their libraries to the subdirectory <samp>lib</samp> the <code>out</code> output.
</p>
<p>It&rsquo;s also assumed that the union of all the dependencies of a package
has no conflicting files.
</p>
<p>For the time being, cross-compilation is not supported - so right now
the libraries and header files are assumed to be host tools.
</p>
</dd></dl>

<dl>
<dt id="index-asdf_002dbuild_002dsystem_002fsource" class="symbol-definition"><span class="symbol-definition-category">Scheme Variable: </span><span class="symbol-definition-prototype">asdf-build-system/source </span></dt>
<dt id="index-asdf_002dbuild_002dsystem_002fsbcl" class="symbol-definition"><span class="symbol-definition-category">Scheme Variable: </span><span class="symbol-definition-prototype">asdf-build-system/sbcl </span></dt>
<dt id="index-asdf_002dbuild_002dsystem_002fecl" class="symbol-definition"><span class="symbol-definition-category">Scheme Variable: </span><span class="symbol-definition-prototype">asdf-build-system/ecl </span></dt>
<dd>
<p>These variables, exported by <code>(guix build-system asdf)</code>, implement
build procedures for Common Lisp packages using
<a href="https://common-lisp.net/project/asdf/">&ldquo;ASDF&rdquo;</a>.  ASDF is a system
definition facility for Common Lisp programs and libraries.
</p>
<p>The <code>asdf-build-system/source</code> system installs the packages in
source form, and can be loaded using any common lisp implementation, via
ASDF.  The others, such as <code>asdf-build-system/sbcl</code>, install binary
systems in the format which a particular implementation understands.
These build systems can also be used to produce executable programs, or
lisp images which contain a set of packages pre-loaded.
</p>
<p>The build system uses naming conventions.  For binary packages, the
package name should be prefixed with the lisp implementation, such as
<code>sbcl-</code> for <code>asdf-build-system/sbcl</code>.
</p>
<p>Additionally, the corresponding source package should be labeled using
the same convention as python packages (see <a href="Python-Modules.html">Python Modules</a>), using
the <code>cl-</code> prefix.
</p>
<p>In order to create executable programs and images, the build-side
procedures <code>build-program</code> and <code>build-image</code> can be used.
They should be called in a build phase after the
<code>create-asdf-configuration</code> phase, so that the system which was
just built can be used within the resulting image.  <code>build-program</code>
requires a list of Common Lisp expressions to be passed as the
<code>#:entry-program</code> argument.
</p>
<p>By default, all the <samp>.asd</samp> files present in the sources are read to
find system definitions.  The <code>#:asd-files</code> parameter can be used
to specify the list of <samp>.asd</samp> files to read.  Furthermore, if the
package defines a system for its tests in a separate file, it will be
loaded before the tests are run if it is specified by the
<code>#:test-asd-file</code> parameter.  If it is not set, the files
<code>&lt;system&gt;-tests.asd</code>, <code>&lt;system&gt;-test.asd</code>, <code>tests.asd</code>,
and <code>test.asd</code> will be tried if they exist.
</p>
<p>If for some reason the package must be named in a different way than the
naming conventions suggest, or if several systems must be compiled, the
<code>#:asd-systems</code> parameter can be used to specify the list of system
names.
</p>
</dd></dl>

<dl>
<dt id="index-cargo_002dbuild_002dsystem" class="symbol-definition"><span class="symbol-definition-category">Scheme Variable: </span><span class="symbol-definition-prototype">cargo-build-system </span></dt>
<dd><span id="index-Rust-programming-language"></span>
<span id="index-Cargo-_0028Rust-build-system_0029"></span>
<p>This variable is exported by <code>(guix build-system cargo)</code>.  It
supports builds of packages using Cargo, the build tool of the
<a href="https://www.rust-lang.org">Rust programming language</a>.
</p>
<p>It adds <code>rustc</code> and <code>cargo</code> to the set of inputs.
A different Rust package can be specified with the <code>#:rust</code> parameter.
</p>
<p>Regular cargo dependencies should be added to the package definition similarly
to other packages; those needed only at build time to native-inputs, others to
inputs.  If you need to add source-only crates then you should add them to via
the <code>#:cargo-inputs</code> parameter as a list of name and spec pairs, where the
spec can be a package or a source definition.  Note that the spec must
evaluate to a path to a gzipped tarball which includes a <code>Cargo.toml</code>
file at its root, or it will be ignored.  Similarly, cargo dev-dependencies
should be added to the package definition via the
<code>#:cargo-development-inputs</code> parameter.
</p>
<p>In its <code>configure</code> phase, this build system will make any source inputs
specified in the <code>#:cargo-inputs</code> and <code>#:cargo-development-inputs</code>
parameters available to cargo.  It will also remove an included
<code>Cargo.lock</code> file to be recreated by <code>cargo</code> during the
<code>build</code> phase.  The <code>package</code> phase will run <code>cargo package</code>
to create a source crate for future use.  The <code>install</code> phase installs
the binaries defined by the crate.  Unless <code>install-source? #f</code> is
defined it will also install a source crate repository of itself and unpacked
sources, to ease in future hacking on rust packages.
</p></dd></dl>

<dl>
<dt id="index-chicken_002dbuild_002dsystem" class="symbol-definition"><span class="symbol-definition-category">Scheme Variable: </span><span class="symbol-definition-prototype">chicken-build-system </span></dt>
<dd><p>This variable is exported by <code>(guix build-system chicken)</code>.  It
builds <a href="https://call-cc.org/">CHICKEN Scheme</a> modules, also called
&ldquo;eggs&rdquo; or &ldquo;extensions&rdquo;.  CHICKEN generates C source code, which then
gets compiled by a C compiler, in this case GCC.
</p>
<p>This build system adds <code>chicken</code> to the package inputs, as well as
the packages of <code>gnu-build-system</code>.
</p>
<p>The build system can&rsquo;t (yet) deduce the egg&rsquo;s name automatically, so just like
with <code>go-build-system</code> and its <code>#:import-path</code>, you should define
<code>#:egg-name</code> in the package&rsquo;s <code>arguments</code> field.
</p>
<p>For example, if you are packaging the <code>srfi-1</code> egg:
</p>
<div class="lisp">
<pre class="lisp"><span class="syntax-paren0">(<span class="syntax-symbol"><span class="syntax-symbol">arguments</span> <span class="syntax-symbol">'</span><span class="syntax-paren1">(<span class="syntax-symbol"><span class="syntax-keyword">#:egg-name</span> <span class="syntax-string">"srfi-1"</span></span>)</span></span>)</span>
</pre></div>

<p>Egg dependencies must be defined in <code>propagated-inputs</code>, not <code>inputs</code>
because CHICKEN doesn&rsquo;t embed absolute references in compiled eggs.
Test dependencies should go to <code>native-inputs</code>, as usual.
</p></dd></dl>

<dl>
<dt id="index-copy_002dbuild_002dsystem" class="symbol-definition"><span class="symbol-definition-category">Scheme Variable: </span><span class="symbol-definition-prototype">copy-build-system </span></dt>
<dd><p>This variable is exported by <code>(guix build-system copy)</code>.  It
supports builds of simple packages that don&rsquo;t require much compiling,
mostly just moving files around.
</p>
<p>It adds much of the <code>gnu-build-system</code> packages to the set of
inputs.  Because of this, the <code>copy-build-system</code> does not require
all the boilerplate code often needed for the
<code>trivial-build-system</code>.
</p>
<p>To further simplify the file installation process, an
<code>#:install-plan</code> argument is exposed to let the packager specify
which files go where.  The install plan is a list of <code>(<var>source</var>
<var>target</var> [<var>filters</var>])</code>.  <var>filters</var> are optional.
</p>
<ul>
<li> When <var>source</var> matches a file or directory without trailing slash, install it to <var>target</var>.
<ul>
<li> If <var>target</var> has a trailing slash, install <var>source</var> basename beneath <var>target</var>.
</li><li> Otherwise install <var>source</var> as <var>target</var>.
</li></ul>

</li><li> When <var>source</var> is a directory with a trailing slash, or when <var>filters</var> are used,
the trailing slash of <var>target</var> is implied with the same meaning
as above.
<ul>
<li> Without <var>filters</var>, install the full <var>source</var> <em>content</em> to <var>target</var>.
</li><li> With <var>filters</var> among <code>#:include</code>, <code>#:include-regexp</code>, <code>#:exclude</code>,
<code>#:exclude-regexp</code>, only select files are installed depending on
the filters.  Each filters is specified by a list of strings.
<ul>
<li> With <code>#:include</code>, install all the files which the path suffix matches
at least one of the elements in the given list.
</li><li> With <code>#:include-regexp</code>, install all the files which the
subpaths match at least one of the regular expressions in the given
list.
</li><li> The <code>#:exclude</code> and <code>#:exclude-regexp</code> filters
are the complement of their inclusion counterpart.  Without <code>#:include</code> flags,
install all files but those matching the exclusion filters.
If both inclusions and exclusions are specified, the exclusions are done
on top of the inclusions.
</li></ul>
</li></ul>
<p>In all cases, the paths relative to <var>source</var> are preserved within
<var>target</var>.
</p></li></ul>

<p>Examples:
</p>
<ul>
<li> <code>("foo/bar" "share/my-app/")</code>: Install <samp>bar</samp> to <samp>share/my-app/bar</samp>.
</li><li> <code>("foo/bar" "share/my-app/baz")</code>: Install <samp>bar</samp> to <samp>share/my-app/baz</samp>.
</li><li> <code>("foo/" "share/my-app")</code>: Install the content of <samp>foo</samp> inside <samp>share/my-app</samp>,
e.g., install <samp>foo/sub/file</samp> to <samp>share/my-app/sub/file</samp>.
</li><li> <code>("foo/" "share/my-app" #:include ("sub/file"))</code>: Install only <samp>foo/sub/file</samp> to
<samp>share/my-app/sub/file</samp>.
</li><li> <code>("foo/sub" "share/my-app" #:include ("file"))</code>: Install <samp>foo/sub/file</samp> to
<samp>share/my-app/file</samp>.
</li></ul>
</dd></dl>


<span id="index-Clojure-_0028programming-language_0029"></span>
<span id="index-simple-Clojure-build-system"></span>
<dl>
<dt id="index-clojure_002dbuild_002dsystem" class="symbol-definition"><span class="symbol-definition-category">Scheme Variable: </span><span class="symbol-definition-prototype">clojure-build-system </span></dt>
<dd><p>This variable is exported by <code>(guix build-system clojure)</code>.  It implements
a simple build procedure for <a href="https://clojure.org/">Clojure</a> packages
using plain old <code>compile</code> in Clojure.  Cross-compilation is not supported
yet.
</p>
<p>It adds <code>clojure</code>, <code>icedtea</code> and <code>zip</code> to the set of inputs.
Different packages can be specified with the <code>#:clojure</code>, <code>#:jdk</code> and
<code>#:zip</code> parameters, respectively.
</p>
<p>A list of source directories, test directories and jar names can be specified
with the <code>#:source-dirs</code>, <code>#:test-dirs</code> and <code>#:jar-names</code>
parameters, respectively.  Compile directory and main class can be specified
with the <code>#:compile-dir</code> and <code>#:main-class</code> parameters, respectively.
Other parameters are documented below.
</p>
<p>This build system is an extension of <code>ant-build-system</code>, but with the
following phases changed:
</p>
<dl compact="compact">
<dt><code>build</code></dt>
<dd><p>This phase calls <code>compile</code> in Clojure to compile source files and runs
<code>jar</code> to create jars from both source files and compiled files
according to the include list and exclude list specified in
<code>#:aot-include</code> and <code>#:aot-exclude</code>, respectively.  The exclude list
has priority over the include list.  These lists consist of symbols
representing Clojure libraries or the special keyword <code>#:all</code> representing
all Clojure libraries found under the source directories.  The parameter
<code>#:omit-source?</code> decides if source should be included into the jars.
</p>
</dd>
<dt><code>check</code></dt>
<dd><p>This phase runs tests according to the include list and exclude list specified
in <code>#:test-include</code> and <code>#:test-exclude</code>, respectively.  Their
meanings are analogous to that of <code>#:aot-include</code> and
<code>#:aot-exclude</code>, except that the special keyword <code>#:all</code> now
stands for all Clojure libraries found under the test directories.  The
parameter <code>#:tests?</code> decides if tests should be run.
</p>
</dd>
<dt><code>install</code></dt>
<dd><p>This phase installs all jars built previously.
</p></dd>
</dl>

<p>Apart from the above, this build system also contains an additional phase:
</p>
<dl compact="compact">
<dt><code>install-doc</code></dt>
<dd><p>This phase installs all top-level files with base name matching
<code>%doc-regex</code>.  A different regex can be specified with the
<code>#:doc-regex</code> parameter.  All files (recursively) inside the documentation
directories specified in <code>#:doc-dirs</code> are installed as well.
</p></dd>
</dl>
</dd></dl>

<dl>
<dt id="index-cmake_002dbuild_002dsystem" class="symbol-definition"><span class="symbol-definition-category">Scheme Variable: </span><span class="symbol-definition-prototype">cmake-build-system </span></dt>
<dd><p>This variable is exported by <code>(guix build-system cmake)</code>.  It
implements the build procedure for packages using the
<a href="https://www.cmake.org">CMake build tool</a>.
</p>
<p>It automatically adds the <code>cmake</code> package to the set of inputs.
Which package is used can be specified with the <code>#:cmake</code>
parameter.
</p>
<p>The <code>#:configure-flags</code> parameter is taken as a list of flags
passed to the <code>cmake</code> command.  The <code>#:build-type</code>
parameter specifies in abstract terms the flags passed to the compiler;
it defaults to <code>"RelWithDebInfo"</code> (short for &ldquo;release mode with
debugging information&rdquo;), which roughly means that code is compiled with
<code>-O2 -g</code>, as is the case for Autoconf-based packages by default.
</p></dd></dl>

<dl>
<dt id="index-dune_002dbuild_002dsystem" class="symbol-definition"><span class="symbol-definition-category">Scheme Variable: </span><span class="symbol-definition-prototype">dune-build-system </span></dt>
<dd><p>This variable is exported by <code>(guix build-system dune)</code>.  It
supports builds of packages using <a href="https://dune.build/">Dune</a>, a build
tool for the OCaml programming language.  It is implemented as an extension
of the <code>ocaml-build-system</code> which is described below.  As such, the
<code>#:ocaml</code> and <code>#:findlib</code> parameters can be passed to this build
system.
</p>
<p>It automatically adds the <code>dune</code> package to the set of inputs.
Which package is used can be specified with the <code>#:dune</code>
parameter.
</p>
<p>There is no <code>configure</code> phase because dune packages typically don&rsquo;t
need to be configured.  The <code>#:build-flags</code> parameter is taken as a
list of flags passed to the <code>dune</code> command during the build.
</p>
<p>The <code>#:jbuild?</code> parameter can be passed to use the <code>jbuild</code>
command instead of the more recent <code>dune</code> command while building
a package.  Its default value is <code>#f</code>.
</p>
<p>The <code>#:package</code> parameter can be passed to specify a package name, which
is useful when a package contains multiple packages and you want to build
only one of them.  This is equivalent to passing the <code>-p</code> argument to
<code>dune</code>.
</p>
</dd></dl>

<dl>
<dt id="index-elm_002dbuild_002dsystem" class="symbol-definition"><span class="symbol-definition-category">Scheme variable: </span><span class="symbol-definition-prototype">elm-build-system </span></dt>
<dd><p>This variable is exported by <code>(guix build-system elm)</code>.  It implements a
build procedure for <a href="https://elm-lang.org">Elm</a> packages similar to
&lsquo;<samp>elm install</samp>&rsquo;.
</p>
<p>The build system adds an Elm compiler package to the set of inputs.  The
default compiler package (currently <code>elm-sans-reactor</code>) can be overridden
using the <code>#:elm</code> argument.  Additionally, Elm packages needed by the
build system itself are added as implicit inputs if they are not already
present: to suppress this behavior, use the
<code>#:implicit-elm-package-inputs?</code> argument, which is primarily useful for
bootstrapping.
</p>
<p>The <code>"dependencies"</code> and <code>"test-dependencies"</code> in an Elm package&rsquo;s
<samp>elm.json</samp> file correspond to <code>propagated-inputs</code> and <code>inputs</code>,
respectively.
</p>
<p>Elm requires a particular structure for package names: see <a href="Elm-Packages.html">Elm Packages</a>
for more details, including utilities provided by <code>(guix build-system
elm)</code>.
</p>
<p>There are currently a few noteworthy limitations to <code>elm-build-system</code>:
</p>
<ul>
<li> The build system is focused on <em>packages</em> in the Elm sense of the word:
Elm <em>projects</em> which declare <code>{ "type": "package" }</code> in their
<samp>elm.json</samp> files.  Using <code>elm-build-system</code> to build Elm
<em>applications</em> (which declare <code>{ "type": "application" }</code>) is
possible, but requires ad-hoc modifications to the build phases.  For
examples, see the definitions of the <code>elm-todomvc</code> example application and
the <code>elm</code> package itself (because the front-end for the
&lsquo;<samp>elm reactor</samp>&rsquo; command is an Elm application).

</li><li> Elm supports multiple versions of a package coexisting simultaneously under
<code>ELM_HOME</code>, but this does not yet work well with <code>elm-build-system</code>.
This limitation primarily affects Elm applications, because they specify
exact versions for their dependencies, whereas Elm packages specify supported
version ranges.  As a workaround, the example applications mentioned above use
the <code>patch-application-dependencies</code> procedure provided by
<code>(guix build elm-build-system)</code> to rewrite their <samp>elm.json</samp> files to
refer to the package versions actually present in the build environment.
Alternatively, Guix package transformations (see <a href="Defining-Package-Variants.html">Defining Package Variants</a>) could be used to rewrite an application&rsquo;s entire dependency graph.

</li><li> We are not yet able to run tests for Elm projects because neither
<a href="https://github.com/mpizenberg/elm-test-rs"><code>elm-test-rs</code></a> nor the
Node.js-based <a href="https://github.com/rtfeldman/node-test-runner"><code>elm-test</code></a> runner has been packaged for Guix yet.
</li></ul>
</dd></dl>

<dl>
<dt id="index-go_002dbuild_002dsystem" class="symbol-definition"><span class="symbol-definition-category">Scheme Variable: </span><span class="symbol-definition-prototype">go-build-system </span></dt>
<dd><p>This variable is exported by <code>(guix build-system go)</code>.  It
implements a build procedure for Go packages using the standard
<a href="https://golang.org/cmd/go/#hdr-Compile_packages_and_dependencies">Go build mechanisms</a>.
</p>
<p>The user is expected to provide a value for the key <code>#:import-path</code>
and, in some cases, <code>#:unpack-path</code>.  The
<a href="https://golang.org/doc/code.html#ImportPaths">import path</a>
corresponds to the file system path expected by the package&rsquo;s build
scripts and any referring packages, and provides a unique way to
refer to a Go package.  It is typically based on a combination of the
package source code&rsquo;s remote URI and file system hierarchy structure.  In
some cases, you will need to unpack the package&rsquo;s source code to a
different directory structure than the one indicated by the import path,
and <code>#:unpack-path</code> should be used in such cases.
</p>
<p>Packages that provide Go libraries should install their source code into
the built output.  The key <code>#:install-source?</code>, which defaults to
<code>#t</code>, controls whether or not the source code is installed.  It can
be set to <code>#f</code> for packages that only provide executable files.
</p>
<p>Packages can be cross-built, and if a specific architecture or operating
system is desired then the keywords <code>#:goarch</code> and <code>#:goos</code>
can be used to force the package to be built for that architecture and
operating system.  The combinations known to Go can be found
<a href="https://guix.gnu.org/manual/en/html_node/&quot;https://golang.org/doc/install/source#environment&quot;">in their
documentation</a>.
</p></dd></dl>

<dl>
<dt id="index-glib_002dor_002dgtk_002dbuild_002dsystem" class="symbol-definition"><span class="symbol-definition-category">Scheme Variable: </span><span class="symbol-definition-prototype">glib-or-gtk-build-system </span></dt>
<dd><p>This variable is exported by <code>(guix build-system glib-or-gtk)</code>.  It
is intended for use with packages making use of GLib or GTK+.
</p>
<p>This build system adds the following two phases to the ones defined by
<code>gnu-build-system</code>:
</p>
<dl compact="compact">
<dt><code>glib-or-gtk-wrap</code></dt>
<dd><p>The phase <code>glib-or-gtk-wrap</code> ensures that programs in
<samp>bin/</samp> are able to find GLib &ldquo;schemas&rdquo; and
<a href="https://developer.gnome.org/gtk3/stable/gtk-running.html">GTK+
modules</a>.  This is achieved by wrapping the programs in launch scripts
that appropriately set the <code>XDG_DATA_DIRS</code> and <code>GTK_PATH</code>
environment variables.
</p>
<p>It is possible to exclude specific package outputs from that wrapping
process by listing their names in the
<code>#:glib-or-gtk-wrap-excluded-outputs</code> parameter.  This is useful
when an output is known not to contain any GLib or GTK+ binaries, and
where wrapping would gratuitously add a dependency of that output on
GLib and GTK+.
</p>
</dd>
<dt><code>glib-or-gtk-compile-schemas</code></dt>
<dd><p>The phase <code>glib-or-gtk-compile-schemas</code> makes sure that all
<a href="https://developer.gnome.org/gio/stable/glib-compile-schemas.html">GSettings schemas</a> of GLib are compiled.  Compilation is performed by the
<code>glib-compile-schemas</code> program.  It is provided by the package
<code>glib:bin</code> which is automatically imported by the build system.
The <code>glib</code> package providing <code>glib-compile-schemas</code> can be
specified with the <code>#:glib</code> parameter.
</p></dd>
</dl>

<p>Both phases are executed after the <code>install</code> phase.
</p></dd></dl>

<dl>
<dt id="index-guile_002dbuild_002dsystem" class="symbol-definition"><span class="symbol-definition-category">Scheme Variable: </span><span class="symbol-definition-prototype">guile-build-system </span></dt>
<dd><p>This build system is for Guile packages that consist exclusively of Scheme
code and that are so lean that they don&rsquo;t even have a makefile, let alone a
<samp>configure</samp> script.  It compiles Scheme code using <code>guild
compile</code> (see <a href="https://www.gnu.org/software/guile/manual/html_node/Compilation.html#Compilation">Compilation</a> in <cite>GNU Guile Reference Manual</cite>) and
installs the <samp>.scm</samp> and <samp>.go</samp> files in the right place.  It also
installs documentation.
</p>
<p>This build system supports cross-compilation by using the
<samp>--target</samp> option of &lsquo;<samp>guild compile</samp>&rsquo;.
</p>
<p>Packages built with <code>guile-build-system</code> must provide a Guile package in
their <code>native-inputs</code> field.
</p></dd></dl>

<dl>
<dt id="index-julia_002dbuild_002dsystem" class="symbol-definition"><span class="symbol-definition-category">Scheme Variable: </span><span class="symbol-definition-prototype">julia-build-system </span></dt>
<dd><p>This variable is exported by <code>(guix build-system julia)</code>.  It
implements the build procedure used by <a href="https://julialang.org/">julia</a> packages, which essentially is similar to running &lsquo;<samp>julia -e
'using Pkg; Pkg.add(package)'</samp>&rsquo; in an environment where
<code>JULIA_LOAD_PATH</code> contains the paths to all Julia package inputs.
Tests are run by calling <code>/test/runtests.jl</code>.
</p>
<p>The Julia package name and uuid is read from the file
<samp>Project.toml</samp>.  These values can be overridden by passing the
argument <code>#:julia-package-name</code> (which must be correctly
capitalized) or <code>#:julia-package-uuid</code>.
</p>
<p>Julia packages usually manage their binary dependencies via
<code>JLLWrappers.jl</code>, a Julia package that creates a module (named
after the wrapped library followed by <code>_jll.jl</code>.
</p>
<p>To add the binary path <code>_jll.jl</code> packages, you need to patch the
files under <samp>src/wrappers/</samp>, replacing the call to the macro
<code>JLLWrappers.@generate_wrapper_header</code>, adding as a second
argument containing the store path the binary.
</p>
<p>As an example, in the MbedTLS Julia package, we add a build phase
(see <a href="Build-Phases.html">Build Phases</a>) to insert the absolute file name of the wrapped
MbedTLS package:
</p>
<div class="lisp">
<pre class="lisp"><span class="syntax-paren0">(<span class="syntax-symbol"><span class="syntax-symbol">add-after</span> <span class="syntax-symbol">'unpack</span> <span class="syntax-symbol">'override-binary-path</span>
  <span class="syntax-paren1">(<span class="syntax-symbol"><a class="syntax-symbol" href="https://www.gnu.org/software/guile/manual/html_node/lambda_002a-and-define_002a.html#index-lambda_002a">lambda*</a> <span class="syntax-paren2">(<span class="syntax-symbol"><span class="syntax-keyword">#:key</span> <span class="syntax-symbol">inputs</span> <span class="syntax-keyword">#:allow-other-keys</span></span>)</span>
    <span class="syntax-paren2">(<span class="syntax-symbol"><span class="syntax-special">for-each</span> <span class="syntax-paren3">(<span class="syntax-symbol"><span class="syntax-special">lambda</span> <span class="syntax-paren4">(<span class="syntax-symbol"><span class="syntax-symbol">wrapper</span></span>)</span>
                <span class="syntax-paren4">(<span class="syntax-symbol"><a class="syntax-symbol" href="Build-Utilities.html#index-substitute_002a">substitute*</a> <span class="syntax-symbol">wrapper</span>
                  <span class="syntax-paren5">(<span class="syntax-symbol"><span class="syntax-paren6">(<span class="syntax-symbol"><span class="syntax-string">"generate_wrapper_header.*"</span></span>)</span>
                   <span class="syntax-paren6">(<span class="syntax-symbol"><a class="syntax-symbol" href="https://www.gnu.org/software/guile/manual/html_node/Reversing-and-Appending-Strings.html#index-string_002dappend">string-append</a>
                    <span class="syntax-string">"generate_wrapper_header(\"MbedTLS\", \""</span>
                    <span class="syntax-paren7">(<span class="syntax-symbol"><a class="syntax-symbol" href="https://www.gnu.org/software/guile/manual/html_node/Retrieving-Alist-Entries.html#index-assoc_002dref">assoc-ref</a> <span class="syntax-symbol">inputs</span> <span class="syntax-string">"mbedtls-apache"</span></span>)</span> <span class="syntax-string">"\")\n"</span></span>)</span></span>)</span></span>)</span></span>)</span>
              <span class="syntax-comment">;; There's a Julia file for each platform, override them all.
</span>              <span class="syntax-paren3">(<span class="syntax-symbol"><a class="syntax-symbol" href="Build-Utilities.html#index-find_002dfiles">find-files</a> <span class="syntax-string">"src/wrappers/"</span> <span class="syntax-string">"\\.jl$"</span></span>)</span></span>)</span></span>)</span></span>)</span>
</pre></div>

<p>Some older packages that aren&rsquo;t using <samp>Project.toml</samp> yet, will
require this file to be created, too.  It is internally done if the
arguments <code>#:julia-package-name</code> and <code>#:julia-package-uuid</code>
are provided.
</p></dd></dl>

<dl>
<dt id="index-maven_002dbuild_002dsystem" class="symbol-definition"><span class="symbol-definition-category">Scheme Variable: </span><span class="symbol-definition-prototype">maven-build-system </span></dt>
<dd><p>This variable is exported by <code>(guix build-system maven)</code>.  It implements
a build procedure for <a href="https://maven.apache.org">Maven</a> packages.  Maven
is a dependency and lifecycle management tool for Java.  A user of Maven
specifies dependencies and plugins in a <samp>pom.xml</samp> file that Maven reads.
When Maven does not have one of the dependencies or plugins in its repository,
it will download them and use them to build the package.
</p>
<p>The maven build system ensures that maven will not try to download any
dependency by running in offline mode.  Maven will fail if a dependency is
missing.  Before running Maven, the <samp>pom.xml</samp> (and subprojects) are
modified to specify the version of dependencies and plugins that match the
versions available in the guix build environment.  Dependencies and plugins
must be installed in the fake maven repository at <samp>lib/m2</samp>, and are
symlinked into a proper repository before maven is run.  Maven is instructed
to use that repository for the build and installs built artifacts there.
Changed files are copied to the <samp>lib/m2</samp> directory of the package output.
</p>
<p>You can specify a <samp>pom.xml</samp> file with the <code>#:pom-file</code> argument,
or let the build system use the default <samp>pom.xml</samp> file in the sources.
</p>
<p>In case you need to specify a dependency&rsquo;s version manually, you can use the
<code>#:local-packages</code> argument.  It takes an association list where the key
is the groupId of the package and its value is an association list where the
key is the artifactId of the package and its value is the version you want to
override in the <samp>pom.xml</samp>.
</p>
<p>Some packages use dependencies or plugins that are not useful at runtime nor
at build time in Guix.  You can alter the <samp>pom.xml</samp> file to remove them
using the <code>#:exclude</code> argument.  Its value is an association list where
the key is the groupId of the plugin or dependency you want to remove, and
the value is a list of artifactId you want to remove.
</p>
<p>You can override the default <code>jdk</code> and <code>maven</code> packages with the
corresponding argument, <code>#:jdk</code> and <code>#:maven</code>.
</p>
<p>The <code>#:maven-plugins</code> argument is a list of maven plugins used during
the build, with the same format as the <code>inputs</code> fields of the package
declaration.  Its default value is <code>(default-maven-plugins)</code> which is
also exported.
</p></dd></dl>

<dl>
<dt id="index-minetest_002dmod_002dbuild_002dsystem" class="symbol-definition"><span class="symbol-definition-category">Scheme Variable: </span><span class="symbol-definition-prototype">minetest-mod-build-system </span></dt>
<dd><p>This variable is exported by <code>(guix build-system minetest)</code>.  It
implements a build procedure for <a href="https://www.minetest.net">Minetest</a>
mods, which consists of copying Lua code, images and other resources to
the location Minetest searches for mods.  The build system also minimises
PNG images and verifies that Minetest can load the mod without errors.
</p></dd></dl>

<dl>
<dt id="index-minify_002dbuild_002dsystem" class="symbol-definition"><span class="symbol-definition-category">Scheme Variable: </span><span class="symbol-definition-prototype">minify-build-system </span></dt>
<dd><p>This variable is exported by <code>(guix build-system minify)</code>.  It
implements a minification procedure for simple JavaScript packages.
</p>
<p>It adds <code>uglify-js</code> to the set of inputs and uses it to compress
all JavaScript files in the <samp>src</samp> directory.  A different minifier
package can be specified with the <code>#:uglify-js</code> parameter, but it
is expected that the package writes the minified code to the standard
output.
</p>
<p>When the input JavaScript files are not all located in the <samp>src</samp>
directory, the parameter <code>#:javascript-files</code> can be used to
specify a list of file names to feed to the minifier.
</p></dd></dl>

<dl>
<dt id="index-ocaml_002dbuild_002dsystem" class="symbol-definition"><span class="symbol-definition-category">Scheme Variable: </span><span class="symbol-definition-prototype">ocaml-build-system </span></dt>
<dd><p>This variable is exported by <code>(guix build-system ocaml)</code>.  It implements
a build procedure for <a href="https://ocaml.org">OCaml</a> packages, which consists
of choosing the correct set of commands to run for each package.  OCaml
packages can expect many different commands to be run.  This build system will
try some of them.
</p>
<p>When the package has a <samp>setup.ml</samp> file present at the top-level, it will
run <code>ocaml setup.ml -configure</code>, <code>ocaml setup.ml -build</code> and
<code>ocaml setup.ml -install</code>.  The build system will assume that this file
was generated by <a href="http://oasis.forge.ocamlcore.org/">OASIS</a> and will take
care of setting the prefix and enabling tests if they are not disabled.  You
can pass configure and build flags with the <code>#:configure-flags</code> and
<code>#:build-flags</code>.  The <code>#:test-flags</code> key can be passed to change the
set of flags used to enable tests.  The <code>#:use-make?</code> key can be used to
bypass this system in the build and install phases.
</p>
<p>When the package has a <samp>configure</samp> file, it is assumed that it is a
hand-made configure script that requires a different argument format than
in the <code>gnu-build-system</code>.  You can add more flags with the
<code>#:configure-flags</code> key.
</p>
<p>When the package has a <samp>Makefile</samp> file (or <code>#:use-make?</code> is
<code>#t</code>), it will be used and more flags can be passed to the build and
install phases with the <code>#:make-flags</code> key.
</p>
<p>Finally, some packages do not have these files and use a somewhat standard
location for its build system.  In that case, the build system will run
<code>ocaml pkg/pkg.ml</code> or <code>ocaml pkg/build.ml</code> and take care of
providing the path to the required findlib module.  Additional flags can
be passed via the <code>#:build-flags</code> key.  Install is taken care of by
<code>opam-installer</code>.  In this case, the <code>opam</code> package must
be added to the <code>native-inputs</code> field of the package definition.
</p>
<p>Note that most OCaml packages assume they will be installed in the same
directory as OCaml, which is not what we want in guix.  In particular, they
will install <samp>.so</samp> files in their module&rsquo;s directory, which is usually
fine because it is in the OCaml compiler directory.  In guix though, these
libraries cannot be found and we use <code>CAML_LD_LIBRARY_PATH</code>.  This
variable points to <samp>lib/ocaml/site-lib/stubslibs</samp> and this is where
<samp>.so</samp> libraries should be installed.
</p></dd></dl>

<dl>
<dt id="index-python_002dbuild_002dsystem" class="symbol-definition"><span class="symbol-definition-category">Scheme Variable: </span><span class="symbol-definition-prototype">python-build-system </span></dt>
<dd><p>This variable is exported by <code>(guix build-system python)</code>.  It
implements the more or less standard build procedure used by Python
packages, which consists in running <code>python setup.py build</code> and
then <code>python setup.py install --prefix=/gnu/store/&hellip;</code>.
</p>
<p>For packages that install stand-alone Python programs under <code>bin/</code>,
it takes care of wrapping these programs so that their
<code>GUIX_PYTHONPATH</code> environment variable points to all the Python
libraries they depend on.
</p>
<p>Which Python package is used to perform the build can be specified with
the <code>#:python</code> parameter.  This is a useful way to force a package
to be built for a specific version of the Python interpreter, which
might be necessary if the package is only compatible with a single
interpreter version.
</p>
<p>By default guix calls <code>setup.py</code> under control of
<code>setuptools</code>, much like <code>pip</code> does.  Some packages are not
compatible with setuptools (and pip), thus you can disable this by
setting the <code>#:use-setuptools?</code> parameter to <code>#f</code>.
</p>
<p>If a <code>"python"</code> output is available, the package is installed into it
instead of the default <code>"out"</code> output. This is useful for packages that
include a Python package as only a part of the software, and thus want to
combine the phases of <code>python-build-system</code> with another build system.
Python bindings are a common usecase.
</p></dd></dl>

<dl>
<dt id="index-pyproject_002dbuild_002dsystem" class="symbol-definition"><span class="symbol-definition-category">Scheme Variable: </span><span class="symbol-definition-prototype">pyproject-build-system </span></dt>
<dd><p>This is a variable exported by <code>guix build-system pyproject</code>.  It
is based on <var>python-build-system</var>, and adds support for
<samp>pyproject.toml</samp> and <a href="https://peps.python.org/pep-0517/">PEP 517</a>.
It also supports a variety of build backends and test frameworks.
</p>
<p>The API is slightly different from <var>python-build-system</var>:
</p><ul>
<li> <code>#:use-setuptools?</code> and <code>#:test-target</code> is removed.
</li><li> <code>#:build-backend</code> is added.  It defaults to <code>#false</code> and will try
to guess the appropriate backend based on <samp>pyproject.toml</samp>.
</li><li> <code>#:test-backend</code> is added.  It defaults to <code>#false</code> and will guess
an appropriate test backend based on what is available in package inputs.
</li><li> <code>#:test-flags</code> is added.  The default is <code>'()</code>.  These flags are
passed as arguments to the test command.  Note that flags for verbose output
is always enabled on supported backends.
</li></ul>

<p>It is considered &ldquo;experimental&rdquo; in that the implementation details are
not set in stone yet, however users are encouraged to try it for new
Python projects (even those using <samp>setup.py</samp>).  The API is subject to
change, but any breaking changes in the Guix channel will be dealt with.
</p>
<p>Eventually this build system will be deprecated and merged back into
<var>python-build-system</var>, probably some time in 2024.
</p></dd></dl>

<dl>
<dt id="index-perl_002dbuild_002dsystem" class="symbol-definition"><span class="symbol-definition-category">Scheme Variable: </span><span class="symbol-definition-prototype">perl-build-system </span></dt>
<dd><p>This variable is exported by <code>(guix build-system perl)</code>.  It
implements the standard build procedure for Perl packages, which either
consists in running <code>perl Build.PL --prefix=/gnu/store/&hellip;</code>,
followed by <code>Build</code> and <code>Build install</code>; or in running
<code>perl Makefile.PL PREFIX=/gnu/store/&hellip;</code>, followed by
<code>make</code> and <code>make install</code>, depending on which of
<code>Build.PL</code> or <code>Makefile.PL</code> is present in the package
distribution.  Preference is given to the former if both <code>Build.PL</code>
and <code>Makefile.PL</code> exist in the package distribution.  This
preference can be reversed by specifying <code>#t</code> for the
<code>#:make-maker?</code> parameter.
</p>
<p>The initial <code>perl Makefile.PL</code> or <code>perl Build.PL</code> invocation
passes flags specified by the <code>#:make-maker-flags</code> or
<code>#:module-build-flags</code> parameter, respectively.
</p>
<p>Which Perl package is used can be specified with <code>#:perl</code>.
</p></dd></dl>

<dl>
<dt id="index-renpy_002dbuild_002dsystem" class="symbol-definition"><span class="symbol-definition-category">Scheme Variable: </span><span class="symbol-definition-prototype">renpy-build-system </span></dt>
<dd><p>This variable is exported by <code>(guix build-system renpy)</code>.  It implements
the more or less standard build procedure used by Ren&rsquo;py games, which consists
of loading <code>#:game</code> once, thereby creating bytecode for it.
</p>
<p>It further creates a wrapper script in <code>bin/</code> and a desktop entry in
<code>share/applications</code>, both of which can be used to launch the game.
</p>
<p>Which Ren&rsquo;py package is used can be specified with <code>#:renpy</code>.
Games can also be installed in outputs other than &ldquo;out&rdquo; by using
<code>#:output</code>.
</p></dd></dl>

<dl>
<dt id="index-qt_002dbuild_002dsystem" class="symbol-definition"><span class="symbol-definition-category">Scheme Variable: </span><span class="symbol-definition-prototype">qt-build-system </span></dt>
<dd><p>This variable is exported by <code>(guix build-system qt)</code>.  It
is intended for use with applications using Qt or KDE.
</p>
<p>This build system adds the following two phases to the ones defined by
<code>cmake-build-system</code>:
</p>
<dl compact="compact">
<dt><code>check-setup</code></dt>
<dd><p>The phase <code>check-setup</code> prepares the environment for running
the checks as commonly used by Qt test programs.
For now this only sets some environment variables:
<code>QT_QPA_PLATFORM=offscreen</code>,
<code>DBUS_FATAL_WARNINGS=0</code> and
<code>CTEST_OUTPUT_ON_FAILURE=1</code>.
</p>
<p>This phase is added before the <code>check</code> phase.
It&rsquo;s a separate phase to ease adjusting if necessary.
</p>
</dd>
<dt><code>qt-wrap</code></dt>
<dd><p>The phase <code>qt-wrap</code>
searches for Qt5 plugin paths, QML paths and some XDG in the inputs
and output.  In case some path is found, all programs in the output&rsquo;s
<samp>bin/</samp>, <samp>sbin/</samp>, <samp>libexec/</samp> and <samp>lib/libexec/</samp> directories
are wrapped in scripts defining the necessary environment variables.
</p>
<p>It is possible to exclude specific package outputs from that wrapping process
by listing their names in the <code>#:qt-wrap-excluded-outputs</code> parameter.
This is useful when an output is known not to contain any Qt binaries, and
where wrapping would gratuitously add a dependency of that output on Qt, KDE,
or such.
</p>
<p>This phase is added after the <code>install</code> phase.
</p></dd>
</dl>
</dd></dl>

<dl>
<dt id="index-r_002dbuild_002dsystem" class="symbol-definition"><span class="symbol-definition-category">Scheme Variable: </span><span class="symbol-definition-prototype">r-build-system </span></dt>
<dd><p>This variable is exported by <code>(guix build-system r)</code>.  It
implements the build procedure used by <a href="https://r-project.org">R</a>
packages, which essentially is little more than running &lsquo;<samp>R CMD
INSTALL --library=/gnu/store/&hellip;</samp>&rsquo; in an environment where
<code>R_LIBS_SITE</code> contains the paths to all R package inputs.  Tests are
run after installation using the R function
<code>tools::testInstalledPackage</code>.
</p></dd></dl>

<dl>
<dt id="index-rakudo_002dbuild_002dsystem" class="symbol-definition"><span class="symbol-definition-category">Scheme Variable: </span><span class="symbol-definition-prototype">rakudo-build-system </span></dt>
<dd><p>This variable is exported by <code>(guix build-system rakudo)</code>.  It
implements the build procedure used by <a href="https://rakudo.org/">Rakudo</a> for <a href="https://perl6.org/">Perl6</a> packages.  It installs the
package to <code>/gnu/store/&hellip;/NAME-VERSION/share/perl6</code> and
installs the binaries, library files and the resources, as well as wrap
the files under the <code>bin/</code> directory.  Tests can be skipped by
passing <code>#f</code> to the <code>tests?</code> parameter.
</p>
<p>Which rakudo package is used can be specified with <code>rakudo</code>.
Which perl6-tap-harness package used for the tests can be specified with
<code>#:prove6</code> or removed by passing <code>#f</code> to the
<code>with-prove6?</code> parameter.
Which perl6-zef package used for tests and installing can be specified
with <code>#:zef</code> or removed by passing <code>#f</code> to the
<code>with-zef?</code> parameter.
</p></dd></dl>

<dl>
<dt id="index-rebar_002dbuild_002dsystem" class="symbol-definition"><span class="symbol-definition-category">Scheme Variable: </span><span class="symbol-definition-prototype">rebar-build-system </span></dt>
<dd><p>This variable is exported by <code>(guix build-system rebar)</code>.  It
implements a build procedure around <a href="https://rebar3.org">rebar3</a>,
a build system for programs written in the Erlang language.
</p>
<p>It adds both <code>rebar3</code> and the <code>erlang</code> to the set of inputs.
Different packages can be specified with the <code>#:rebar</code> and
<code>#:erlang</code> parameters, respectively.
</p>
<p>This build system is based on <code>gnu-build-system</code>, but with the
following phases changed:
</p>
<dl compact="compact">
<dt><code>unpack</code></dt>
<dd><p>This phase, after unpacking the source like the <code>gnu-build-system</code>
does, checks for a file <code>contents.tar.gz</code> at the top-level of the
source.  If this file exists, it will be unpacked, too.  This eases
handling of package hosted at <a href="https://hex.pm/">https://hex.pm/</a>,
the Erlang and Elixir package repository.
</p>
</dd>
<dt><code>bootstrap</code></dt>
<dt><code>configure</code></dt>
<dd><p>There are no <code>bootstrap</code> and <code>configure</code> phase because erlang
packages typically don’t need to be configured.
</p>
</dd>
<dt><code>build</code></dt>
<dd><p>This phase runs <code>rebar3 compile</code>
with the flags listed in <code>#:rebar-flags</code>.
</p>
</dd>
<dt><code>check</code></dt>
<dd><p>Unless <code>#:tests? #f</code> is passed,
this phase runs <code>rebar3 eunit</code>,
or some other target specified with <code>#:test-target</code>,
with the flags listed in <code>#:rebar-flags</code>,
</p>
</dd>
<dt><code>install</code></dt>
<dd><p>This installs the files created in the <i>default</i> profile, or some
other profile specified with <code>#:install-profile</code>.
</p>
</dd>
</dl>
</dd></dl>

<dl>
<dt id="index-texlive_002dbuild_002dsystem" class="symbol-definition"><span class="symbol-definition-category">Scheme Variable: </span><span class="symbol-definition-prototype">texlive-build-system </span></dt>
<dd><p>This variable is exported by <code>(guix build-system texlive)</code>.  It is
used to build TeX packages in batch mode with a specified engine.  The
build system sets the <code>TEXINPUTS</code> variable to find all TeX source
files in the inputs.
</p>
<p>By default it runs <code>luatex</code> on all files ending on <code>ins</code>.  A
different engine and format can be specified with the
<code>#:tex-format</code> argument.  Different build targets can be specified
with the <code>#:build-targets</code> argument, which expects a list of file
names.  The build system adds only <code>texlive-bin</code> and
<code>texlive-latex-base</code> (both from <code>(gnu packages tex</code>) to the
inputs.  Both can be overridden with the arguments <code>#:texlive-bin</code>
and <code>#:texlive-latex-base</code>, respectively.
</p>
<p>The <code>#:tex-directory</code> parameter tells the build system where to
install the built files under the texmf tree.
</p></dd></dl>

<dl>
<dt id="index-ruby_002dbuild_002dsystem" class="symbol-definition"><span class="symbol-definition-category">Scheme Variable: </span><span class="symbol-definition-prototype">ruby-build-system </span></dt>
<dd><p>This variable is exported by <code>(guix build-system ruby)</code>.  It
implements the RubyGems build procedure used by Ruby packages, which
involves running <code>gem build</code> followed by <code>gem install</code>.
</p>
<p>The <code>source</code> field of a package that uses this build system
typically references a gem archive, since this is the format that Ruby
developers use when releasing their software.  The build system unpacks
the gem archive, potentially patches the source, runs the test suite,
repackages the gem, and installs it.  Additionally, directories and
tarballs may be referenced to allow building unreleased gems from Git or
a traditional source release tarball.
</p>
<p>Which Ruby package is used can be specified with the <code>#:ruby</code>
parameter.  A list of additional flags to be passed to the <code>gem</code>
command can be specified with the <code>#:gem-flags</code> parameter.
</p></dd></dl>

<dl>
<dt id="index-waf_002dbuild_002dsystem" class="symbol-definition"><span class="symbol-definition-category">Scheme Variable: </span><span class="symbol-definition-prototype">waf-build-system </span></dt>
<dd><p>This variable is exported by <code>(guix build-system waf)</code>.  It
implements a build procedure around the <code>waf</code> script.  The common
phases&mdash;<code>configure</code>, <code>build</code>, and <code>install</code>&mdash;are
implemented by passing their names as arguments to the <code>waf</code>
script.
</p>
<p>The <code>waf</code> script is executed by the Python interpreter.  Which
Python package is used to run the script can be specified with the
<code>#:python</code> parameter.
</p></dd></dl>

<dl>
<dt id="index-scons_002dbuild_002dsystem" class="symbol-definition"><span class="symbol-definition-category">Scheme Variable: </span><span class="symbol-definition-prototype">scons-build-system </span></dt>
<dd><p>This variable is exported by <code>(guix build-system scons)</code>.  It
implements the build procedure used by the SCons software construction
tool.  This build system runs <code>scons</code> to build the package,
<code>scons test</code> to run tests, and then <code>scons install</code> to install
the package.
</p>
<p>Additional flags to be passed to <code>scons</code> can be specified with the
<code>#:scons-flags</code> parameter.  The default build and install targets
can be overridden with <code>#:build-targets</code> and
<code>#:install-targets</code> respectively.  The version of Python used to
run SCons can be specified by selecting the appropriate SCons package
with the <code>#:scons</code> parameter.
</p></dd></dl>

<dl>
<dt id="index-haskell_002dbuild_002dsystem" class="symbol-definition"><span class="symbol-definition-category">Scheme Variable: </span><span class="symbol-definition-prototype">haskell-build-system </span></dt>
<dd><p>This variable is exported by <code>(guix build-system haskell)</code>.  It
implements the Cabal build procedure used by Haskell packages, which
involves running <code>runhaskell Setup.hs configure
--prefix=/gnu/store/&hellip;</code> and <code>runhaskell Setup.hs build</code>.
Instead of installing the package by running <code>runhaskell Setup.hs
install</code>, to avoid trying to register libraries in the read-only
compiler store directory, the build system uses <code>runhaskell
Setup.hs copy</code>, followed by <code>runhaskell Setup.hs register</code>.  In
addition, the build system generates the package documentation by
running <code>runhaskell Setup.hs haddock</code>, unless <code>#:haddock? #f</code>
is passed.  Optional Haddock parameters can be passed with the help of
the <code>#:haddock-flags</code> parameter.  If the file <code>Setup.hs</code> is
not found, the build system looks for <code>Setup.lhs</code> instead.
</p>
<p>Which Haskell compiler is used can be specified with the <code>#:haskell</code>
parameter which defaults to <code>ghc</code>.
</p></dd></dl>

<dl>
<dt id="index-dub_002dbuild_002dsystem" class="symbol-definition"><span class="symbol-definition-category">Scheme Variable: </span><span class="symbol-definition-prototype">dub-build-system </span></dt>
<dd><p>This variable is exported by <code>(guix build-system dub)</code>.  It
implements the Dub build procedure used by D packages, which
involves running <code>dub build</code> and <code>dub run</code>.
Installation is done by copying the files manually.
</p>
<p>Which D compiler is used can be specified with the <code>#:ldc</code>
parameter which defaults to <code>ldc</code>.
</p></dd></dl>

<span id="emacs_002dbuild_002dsystem"></span><dl>
<dt id="index-emacs_002dbuild_002dsystem" class="symbol-definition"><span class="symbol-definition-category">Scheme Variable: </span><span class="symbol-definition-prototype">emacs-build-system </span></dt>
<dd><p>This variable is exported by <code>(guix build-system emacs)</code>.  It
implements an installation procedure similar to the packaging system
of Emacs itself (see <a href="https://www.gnu.org/software/emacs/manual/html_node/emacs/Packages.html#Packages">Packages</a> in <cite>The GNU Emacs Manual</cite>).
</p>
<p>It first creates the <code><code>package</code>-autoloads.el</code> file, then it
byte compiles all Emacs Lisp files.  Differently from the Emacs
packaging system, the Info documentation files are moved to the standard
documentation directory and the <samp>dir</samp> file is deleted.  The Elisp
package files are installed directly under <samp>share/emacs/site-lisp</samp>.
</p></dd></dl>

<dl>
<dt id="index-font_002dbuild_002dsystem" class="symbol-definition"><span class="symbol-definition-category">Scheme Variable: </span><span class="symbol-definition-prototype">font-build-system </span></dt>
<dd><p>This variable is exported by <code>(guix build-system font)</code>.  It
implements an installation procedure for font packages where upstream
provides pre-compiled TrueType, OpenType, etc. font files that merely
need to be copied into place.  It copies font files to standard
locations in the output directory.
</p></dd></dl>

<dl>
<dt id="index-meson_002dbuild_002dsystem" class="symbol-definition"><span class="symbol-definition-category">Scheme Variable: </span><span class="symbol-definition-prototype">meson-build-system </span></dt>
<dd><p>This variable is exported by <code>(guix build-system meson)</code>.  It
implements the build procedure for packages that use
<a href="https://mesonbuild.com">Meson</a> as their build system.
</p>
<p>It adds both Meson and <a href="https://ninja-build.org/">Ninja</a> to the set
of inputs, and they can be changed with the parameters <code>#:meson</code>
and <code>#:ninja</code> if needed.
</p>
<p>This build system is an extension of <code>gnu-build-system</code>, but with the
following phases changed to some specific for Meson:
</p>
<dl compact="compact">
<dt><code>configure</code></dt>
<dd><p>The phase runs <code>meson</code> with the flags specified in
<code>#:configure-flags</code>.  The flag <samp>--buildtype</samp> is always set to
<code>debugoptimized</code> unless something else is specified in
<code>#:build-type</code>.
</p>
</dd>
<dt><code>build</code></dt>
<dd><p>The phase runs <code>ninja</code> to build the package in parallel by default, but
this can be changed with <code>#:parallel-build?</code>.
</p>
</dd>
<dt><code>check</code></dt>
<dd><p>The phase runs &lsquo;<samp>meson test</samp>&rsquo; with a base set of options that cannot
be overridden.  This base set of options can be extended via the
<code>#:test-options</code> argument, for example to select or skip a specific
test suite.
</p>
</dd>
<dt><code>install</code></dt>
<dd><p>The phase runs <code>ninja install</code> and can not be changed.
</p></dd>
</dl>

<p>Apart from that, the build system also adds the following phases:
</p>
<dl compact="compact">
<dt><code>fix-runpath</code></dt>
<dd><p>This phase ensures that all binaries can find the libraries they need.
It searches for required libraries in subdirectories of the package
being built, and adds those to <code>RUNPATH</code> where needed.  It also
removes references to libraries left over from the build phase by
<code>meson</code>, such as test dependencies, that aren&rsquo;t actually required
for the program to run.
</p>
</dd>
<dt><code>glib-or-gtk-wrap</code></dt>
<dd><p>This phase is the phase provided by <code>glib-or-gtk-build-system</code>, and it
is not enabled by default.  It can be enabled with <code>#:glib-or-gtk?</code>.
</p>
</dd>
<dt><code>glib-or-gtk-compile-schemas</code></dt>
<dd><p>This phase is the phase provided by <code>glib-or-gtk-build-system</code>, and it
is not enabled by default.  It can be enabled with <code>#:glib-or-gtk?</code>.
</p></dd>
</dl>
</dd></dl>

<dl>
<dt id="index-linux_002dmodule_002dbuild_002dsystem" class="symbol-definition"><span class="symbol-definition-category">Scheme Variable: </span><span class="symbol-definition-prototype">linux-module-build-system </span></dt>
<dd><p><code>linux-module-build-system</code> allows building Linux kernel modules.
</p>
<span id="index-build-phases-1"></span>
<p>This build system is an extension of <code>gnu-build-system</code>, but with the
following phases changed:
</p>
<dl compact="compact">
<dt><code>configure</code></dt>
<dd><p>This phase configures the environment so that the Linux kernel&rsquo;s Makefile
can be used to build the external kernel module.
</p>
</dd>
<dt><code>build</code></dt>
<dd><p>This phase uses the Linux kernel&rsquo;s Makefile in order to build the external
kernel module.
</p>
</dd>
<dt><code>install</code></dt>
<dd><p>This phase uses the Linux kernel&rsquo;s Makefile in order to install the external
kernel module.
</p></dd>
</dl>

<p>It is possible and useful to specify the Linux kernel to use for building
the module (in the <code>arguments</code> form of a package using the
<code>linux-module-build-system</code>, use the key <code>#:linux</code> to specify it).
</p></dd></dl>

<dl>
<dt id="index-node_002dbuild_002dsystem" class="symbol-definition"><span class="symbol-definition-category">Scheme Variable: </span><span class="symbol-definition-prototype">node-build-system </span></dt>
<dd><p>This variable is exported by <code>(guix build-system node)</code>.  It
implements the build procedure used by <a href="https://nodejs.org">Node.js</a>, which implements an approximation of the <code>npm install</code>
command, followed by an <code>npm test</code> command.
</p>
<p>Which Node.js package is used to interpret the <code>npm</code> commands can
be specified with the <code>#:node</code> parameter which defaults to
<code>node</code>.
</p></dd></dl>

<p>Lastly, for packages that do not need anything as sophisticated, a
&ldquo;trivial&rdquo; build system is provided.  It is trivial in the sense that
it provides basically no support: it does not pull any implicit inputs,
and does not have a notion of build phases.
</p>
<dl>
<dt id="index-trivial_002dbuild_002dsystem" class="symbol-definition"><span class="symbol-definition-category">Scheme Variable: </span><span class="symbol-definition-prototype">trivial-build-system </span></dt>
<dd><p>This variable is exported by <code>(guix build-system trivial)</code>.
</p>
<p>This build system requires a <code>#:builder</code> argument.  This argument
must be a Scheme expression that builds the package output(s)&mdash;as
with <code>build-expression-&gt;derivation</code> (see <a href="Derivations.html"><code>build-expression-&gt;derivation</code></a>).
</p></dd></dl>

<dl>
<dt id="index-channel_002dbuild_002dsystem" class="symbol-definition"><span class="symbol-definition-category">Scheme Variable: </span><span class="symbol-definition-prototype">channel-build-system </span></dt>
<dd><p>This variable is exported by <code>(guix build-system channel)</code>.
</p>
<p>This build system is meant primarily for internal use.  A package using
this build system must have a channel specification as its <code>source</code>
field (see <a href="Channels.html">Channels</a>); alternatively, its source can be a directory
name, in which case an additional <code>#:commit</code> argument must be
supplied to specify the commit being built (a hexadecimal string).
</p>
<p>The resulting package is a Guix instance of the given channel, similar
to how <code>guix time-machine</code> would build it.
</p></dd></dl>

<hr />
<div class="header">
<p>
Next: <a href="Build-Phases.html" accesskey="n" rel="next">Build Phases</a>, Previous: <a href="Writing-Manifests.html" accesskey="p" rel="prev">Writing Manifests</a>, Up: <a href="Programming-Interface.html" accesskey="u" rel="up">Programming Interface</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Concept-Index.html" title="Index" rel="index">Index</a>]</p>
</div>



</body>
</html>
